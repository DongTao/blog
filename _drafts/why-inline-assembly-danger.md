---
layout: post
title: 为什么内联汇编很危险
---
一个例子
======
《程序员的自我修养》书中7.7.5节"运行时状态的演示程序"展示了一种"手动反射"的方法来调用没有头文件的动态库中的函数，主要原理是通过使用**内联汇编**手动压栈的方式，将编译期未知的函数参数信息推迟到运行时决定，下面是一个简化的例子。

```c
void fun(int i) {
}
int main(void) {
    int a = 10;
    void (*myfun)()  = fun;
    asm volatile("push %0\n"::"r"(a));
    myfun();
    asm volatile("add %0,%%esp\n"::"r"(sizeof(a)));
    return 0;
}
```

这段代码做了这么几件事：

1. 将有参fun函数赋给无参函数指针myfun;
2. 用内联汇编将a压栈，造出有参fun函数的调用环境，注意此时改变了main函数帧的栈顶;
3. 调用myfun函数;
4. 还原main函数的堆栈，将栈顶移回调用myfun前的位置

在分析这段代码能否生效之前我们先回顾一下函数调用的过程：

> 1. 依照从右到左的顺序将参数压栈;
> 2. 保存函数返回地址，也就是 .text 代码段中下一条指令的地址;
> 3. 保存调用帧的栈底地址;
> 4. 将esp, ebp寄存器指向新的栈帧;
> 5. 执行函数内指令;
> 6. 函数结束准备返回，将调用帧的栈底地址弹出到ebp寄存器;
> 7. 弹出函数返回地址恢复调用现场

入栈以后也就是下面这个样子

![Function Stack]({{ site.baseurl }}/images/function_stack_800w.png)


