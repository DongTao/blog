---
layout: post
title: 为什么内联汇编很危险
---
一个例子
======
《程序员的自我修养》书中7.7.5节"运行时状态的演示程序"展示了一种"手动反射"的方法来调用没有头文件的动态库中的函数，主要原理是通过使用**内联汇编**手动压栈的方式，将编译期未知的函数参数信息推迟到运行时决定，下面是一个简化的例子。

```c
#include <stdio.h>
void fun(int i) {
    printf("%d\n",i);
}
int main(void) {
    int a = 10;
    void (*myfun)()  = fun;
    asm volatile("push %0\n"::"r"(a));
    myfun();
    asm volatile("add %0,%%esp\n"::"r"(sizeof(a)));
    return 0;
}
```

这段代码做了这么几件事：

1. 将有参fun函数赋给无参函数指针myfun;
2. 用内联汇编将a压栈，造出有参fun函数的调用环境，注意此时改变了main函数帧的栈顶;
3. 调用myfun函数;
4. 还原main函数的堆栈，将栈顶移回调用myfun前的位置

在分析这段代码能否生效之前我们先回顾一下函数调用的过程：

> 1. 依照从右到左的顺序将参数压栈;
> 2. 保存函数返回地址，也就是 .text 代码段中下一条指令的地址;
> 3. 保存调用帧的栈底地址;
> 4. 将esp, ebp寄存器指向新的栈帧;
> 5. 执行函数内指令;
> 6. 函数结束准备返回，将调用帧的栈底地址弹出到ebp寄存器;
> 7. 弹出函数返回地址恢复调用现场

入栈以后也就是下面这个样子

![Function Stack]({{ site.baseurl }}/images/function_stack_800w.png)

对照函数压栈过程，可以看出来上面那段代码中的内联汇编替代了步骤1，并对步骤7做了补充以恢复调用栈，可以认为是在一个无参无返回值函数的调用栈之上再使用内联汇编增加了一层参数栈，从而构建了一个有参函数调用栈，如下图所示

![Inline Assembly Stack]({{ site.baseurl }}/images/inline_assembly_stack_800w.png)

目前看起来一切OK，理论上这种hack手法可以将函数定义推迟到运行期决定，并且实现很简单，不幸的是，这段代码很可能无法如预期的那样工作。

无法工作?
======
是的，在我的系统上一运行这段代码编译的程序就会给我一个华丽丽的Segmentation fault(core dumped)，我的编译和运行环境都是Ubuntu14.04.3 LTS，gcc版本4.8.4，而当我在另一台机器上(Red Hat 5.4, gcc 4.1.2)运行这个程序时却如预期的打印了a的值10。为了了解这部分差异，我们分别在两个环境下用编译器生成汇编汇编代码进行对比，gcc生成汇编的方法如下

> gcc -S main.c

截取两个版本的编译器生成的main函数汇编代码如下

![Assembly Compare]({{ site.baseurl }}/images/assembly_compare_1.png)

左边对应gcc 4.1.2生成的汇编，右边对应gcc 4.8.4生成的汇编，重点关注左边28～36行与右边31~39行的差异。
对应28行和31行，两边都是采用预分配的方式在一开始就为main函数调用栈申请足够的空间，但是之后的所有指令都出现了一个根本上的差异，就是间接寻址的方式。左边采用了ebp寄存器保存的栈底地址作为基址，在此基础上偏移寻找局部变量，而右边采用了相反的方式，以esp寄存器保存的栈顶地址作为基址来偏移寻找变量。不管采用栈顶还是栈底地址作为基址，正确的寻址有一个前提条件，就是基址一定不会在编译器不知道的情况下改变，否则就会访问到错误的地址。首先看一下ebp保存的栈底地址，通常来说，在入栈之后出栈之前，栈底地址都是不会改变的，因为ebp是串联起整个线程调用堆栈链表的头指针，一旦出栈前ebp的值被修改，会导致出栈无法恢复调用现场，也就是所谓的堆栈被破坏，所以采用ebp作为基址是安全的。而esp保存的栈顶地址则不同，可能在栈中发生变化，按照通常的理解局部变量入栈通常是采用push的方式在扩充栈空间的同时将变量保存到栈顶，这样每当有局部变量和函数调用的地方就会有esp的变动，而现代编译器普遍优化做法是预先计算栈空间大小，一次申请完成，这样可以减少大量寄存器操作，在这种情况下esp保存的栈顶地址也不会在栈中发生变化。
但是使用内联汇编以后情况就不一样了，内联汇编是直接嵌入到代码生成的汇编语言中的，编译器不会考虑内联汇编来调整生成的汇编指令，也就是说如果内联汇编修改了调用栈，编译器依然会按照没有被修改的调用栈去生成汇编指令

