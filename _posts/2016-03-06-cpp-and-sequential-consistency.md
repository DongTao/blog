---
layout: post
title: 聊聊C++和顺序一致性
categories:
- 并发编程
- C++
---
关于并发和多线程编程的资料之前查阅了不少，这里整理一下近来的思考过程作为备忘。

哲学家进餐与顺序一致性(Sequential Consistency)
======

![Philosopher1-2]({{ site.baseurl }}/images/cpp-and-sequential-consistency/philosopher1-2.png)

哲学家进餐是一个经典问题，用来描述并发计算中多线程同步遇到的问题。问题是这样的，5个哲学家在一张桌子上，他们只会处于“思考”和“吃饭”两种状态之一，桌上只有5把刀或者叉，如果哲学家要吃饭就必须拿起左右手的刀叉进餐。
显然，刀叉是一种共享资源，每个刀叉被相邻的两个哲学家所共享，当两个相邻的哲学家一起进入“吃饭”状态时，竞态态条件出现了，比如上图左的2号叉就是这种情况，谁先拿到另一方就只能等待，而且为了能够第一时间进入“吃饭”状态需要将另一只手的叉子先拿在手上，如1号叉，这势必又与共享1号叉的哲学家形成了竞态条件。
假如每个哲学家都遵循先左后右的规则拿起桌上的叉子，在一个拿起两把叉子的周期中，如果5个哲学家按照顺时针开始进餐就会出现上图右的死锁情况，所有人都在等右边的人放下叉子，所有人都无法吃饭，也就是死锁了。

<!--more-->

那么死锁的原因究竟是什么？只要共享叉子就一定会有死锁吗？当然不是，问题出在拿叉子的顺序上，以图一为例，如果A和B都是先拿2号叉的话那么发生竞态条件的时候最多只会有2只叉子被占用，比如B先抢到2号叉，然后B才会去拿3号叉，而A拿不到2号叉就不会去拿1号叉，进而图2中的死锁情况就不会出现，因为无法形成一个等待环。

![Philosopher3]({{ site.baseurl }}/images/cpp-and-sequential-consistency/philosopher3.png)

如上图，将叉子编号，所有哲学家按照 1 > 2 > 3 > 4 > 5 的权重顺序拿叉子，需要1和5的哲学家也必须按照1 > 5的顺序拿叉子，这样就不会出现死锁，这就是顺序一致性，这是不产生死锁的数学保证，也是某些依赖执行顺序的程序逻辑正确性的保证。
如果将每个哲学家看做是一个线程，每个叉子看做是一条访问共享资源的指令，那么顺序一致性的问题就可以描述为2点：

1. 在同一个线程内指令执行的顺序一致(从单个线程的视角来看)；
2. 线程执行的顺序可以是交错的，但所有线程中整体的指令执行的顺序是一致的(从整个程序的角度来看，可以想象左右手手指交错的情况)

实现这2点并没有看起来那么简单，尤其是对于C++，因为在语言层面上C++11以前没有任何对多线程的支持，也没有考虑乱序执行对于多线程的巨大挑战，我们只能依赖第三方库提供的一些有限特性支持去小心翼翼的开发"不靠谱"的多线程程序。在C++11以后多线程得到了语言层面上的支持，但采用的也是一种折中的方案，在顺序一致性和乱序获取性能之间让程序员自行取舍，这对于开发人员的要求很高，对于语言的发展来说不是一件好事。都是题外话，现在来看看上面顺序一致性的2点有什么坑以及如何保证顺序一致性吧。

线程内的顺序一致性
======
首先是同一个线程内指令执行的顺序一致性问题。这个问题很常见，因为在串行编程时代指令乱序并不会对程序的结果有任何影响，大多数编译器都利用这一点进行代码优化，例如将读操作提前，而像 double-checked locking(双重锁定检查模式) 这样的之所以被部分人认为是反模式，很大原因就是指令乱序。
那么如何在C++中保证线程内的顺序一致性呢？

* a. 容易想到的第一种方案是采用 volatile，实际上C++中大部分采用volatile来保证顺序一致性的方案都是错误的，因为C++中的volatile关键字并没有顺序性的保证，它仅仅保证被声明的变量不可优化，以及volatile变量之间的执行顺序不被编译器改变，如果使用此方案就需要将所有共享变量都声明为volatile，参见何登成的blog《[C/C++ Volatile关键词深度剖析](http://hedengcheng.com/?p=725)》 。但悲剧的是，这个方案依然无法保证顺序一致性，因为在编译器层面上的顺序一致性无法被CPU流水线所保证，依然可能出现乱序执行，所以单纯依靠广泛使用的C++03的语言特性是无法做到的。真是悲剧，连单线程执行指令的顺序一致性都无法保证，C++真是难以掌控。。。

* b. 事实上还有另一种方案可以真正的解决这个问题，那就是使用 Memory Barrier(内存屏障)。内存屏障是底层原语，是内存排序的一部分,在不同体系结构下变化很大而不适合推广。需要认真研读硬件的手册以确定内存屏障的办法。这种方案会导致难以写出在不同硬件平台下可移植的C++代码，并且在分层体系下程序员有必要但没有义务去学习这部分知识。在wiki上查阅内存屏障词条有以下内容。我在gcc4.1.2下测试了内联汇编的方案，发现汇编优化乱序的情况依然存在，所以这条指令的有效性暂时存疑。

> 编译器会对生成的可执行代码做一定优化，造成乱序执行甚至省略（不执行）。gcc编译器在遇到内嵌汇编语句：

> **asm volatile("" ::: "memory");**

> 将以此作为一条内存屏障，重排序内存操作。即此语句之前的各种编译优化将不会持续到此语句之后。也可用内建的__sync_synchronize
> Microsoft Visual C++的编译器内存屏障为：

> **_ReadWriteBarrier() MemoryBarrier()**

> Intel C++编译器的内存屏障为：

> **__memory_barrier()**

* c. 其实我们常用的锁是能够在某种意义上保证顺序一致性的，比如pthread提供的mutex是具有acquire和release语义的，加锁实际上就成为了一个内存屏障，确保锁内的代码不会被编译器优化或是CPU乱序到锁外执行！但是acquire和release语义并不保证锁外的代码被优化到锁内执行，而且加解锁本身会消耗很多时钟周期，所以很可惜锁并非解决顺序一致性的银弹。关于acquire和release语义可以参看preshing的文章《[Acquire and Release Semantics](http://preshing.com/20120913/acquire-and-release-semantics/)》，这里借用它的一幅图

![Acquire and Release]({{ site.baseurl }}/images/cpp-and-sequential-consistency/acquire_and_release.png)

* d. 那么在语言层面上就没有真正的解决方案吗？理论上来说在C++11之后我们才有了真正的解决方案，因为C++11中定义了C++的多线程内存模型，引入了C++原生的内存屏障---atomic类型。在C++11中，为了满足对性能的追求，atomic类型提供了三种顺序属性：sequential consistency ordering（即顺序一致性），acquire release ordering以及relaxed ordering。C++1x中的多线程内存模型为了通过atomic类型提供足够的灵活性和性能，最大限度地将底层细节（三种不同的顺序属性）暴露给了程序员。这样的设计原则一方面给程序员提供了实现高性能多线程算法的可能，但却也大大增加了使用上的难度。这里有篇[blog](http://www.parallellabs.com/2011/08/27/c-plus-plus-memory-model)作为参考，从结论来看就是下面这句话。

> "我个人的建议是，如果常规的mutex锁、条件变量、future信号能满足您的设计需求，那么您完全不需要使用atomic变量。如果您决定使用atomic变量，请尽量使用默认的顺序一致性属性。"

基本等于没有结论，总之C++在多线程的道路上依然很多坑，没有银弹，你只能自己掌控一切。

整体程序指令的顺序一致性
======
直接使用何登成blog中的一个例子，代码截图如下

![Sequential Consistency Example 1]({{ site.baseurl }}/images/cpp-and-sequential-consistency/sq_example1.png)

实际上这是一个线程内指令顺序一致性的问题，something的赋值语句和flag的赋值语句中间需要一个内存屏障来保证顺序(把读写flag锁起来就OK)，当线程内做到了顺序一致性，那么程序整体指令的顺序也就自然理顺了。
但是我更加在意的是什么情况下我会写出这样的代码逻辑，或者说在编码阶段如何尽量减少程序正确性对顺序一致性的依赖。比如上面那段代码很可能出现在观察者模式的pull实现中，thread1是一个数据准备线程，thread2是一个数据拉取线程，当thread1将数据准备完毕后就将标志位置位，thread2轮询扫描标志位，当检查到置位后就读取数据。下面纯粹是个人想法，不论对错全面与否，权当讨论：

* a. 首先依赖于something的结果却需要分开在两个线程中执行的原因可能是为了复用代码，something有多种利用情况，需要在不同条件下进行不同的处理。《重构》告诉我们，这种情况使用全局变量还不如传参。这样也基本可以确保顺序一致性。

![Sequential Consistency Example 2]({{ site.baseurl }}/images/cpp-and-sequential-consistency/sq_example2.png)

* b. 在保证合理性的前提下，就遵从直觉把这种顺序强依赖的代码放在一起吧

![Sequential Consistency Example 3]({{ site.baseurl }}/images/cpp-and-sequential-consistency/sq_example3.png)

* c. 锁！锁！锁！虽然可能影响一些性能，但是可用性总是优先于性能对吧

![Sequential Consistency Example 4]({{ site.baseurl }}/images/cpp-and-sequential-consistency/sq_example4.png)

(完)
